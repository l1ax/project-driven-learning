# Project Breakdown Guidelines

## Principles for Breaking Down Projects into Stages

### 1. Progressive Complexity
Each stage should build on previous stages while introducing new concepts gradually:
- Start with foundational features
- Add complexity incrementally
- Ensure each stage is functional on its own

### 2. Clear Milestones
Each stage should have:
- A concrete, testable deliverable
- Visible progress (something the user can see/interact with)
- A sense of accomplishment upon completion

### 3. Balanced Scope
Aim for stages that are:
- **Not too large**: Can be completed in reasonable time (hours to days, not weeks)
- **Not too small**: Substantial enough to feel meaningful
- **Roughly equal**: Similar complexity and effort across stages

### 4. Logical Dependencies
Order stages so that:
- Prerequisites are learned before they're needed
- Core functionality comes before enhancements
- Basic features precede advanced features

## Stage Structure Template

Each stage should include:

### Stage N: [Descriptive Name]

**Goal**: Clear statement of what will be achieved

**Prerequisites**:
- Knowledge point 1
- Knowledge point 2
- ...

**What You'll Learn**:
- New concept 1
- New concept 2
- ...

**Implementation Tasks**:
1. Specific task 1
2. Specific task 2
3. ...

**Acceptance Criteria**:
- [ ] Criterion 1
- [ ] Criterion 2
- [ ] ...

**Learning Resources**:
- [Resource 1 Title](URL) - Brief description
- [Resource 2 Title](URL) - Brief description

**Knowledge Check**:
Before proceeding, ensure you can:
- [ ] Explain [concept] in your own words
- [ ] Write [functionality] without looking at examples
- [ ] Debug common issues related to [topic]

## Common Project Stage Patterns

### Web Application Pattern
1. **Stage 1**: Setup & Static UI
   - Project initialization, basic HTML/CSS
2. **Stage 2**: Core Functionality
   - Main feature implementation, basic interactivity
3. **Stage 3**: Data Management
   - State management, data persistence
4. **Stage 4**: Enhanced Features
   - Additional features, UI improvements
5. **Stage 5**: Polish & Deploy
   - Error handling, optimization, deployment

### API/Backend Pattern
1. **Stage 1**: Basic Server Setup
   - Server initialization, basic routing
2. **Stage 2**: Core Endpoints
   - CRUD operations, basic validation
3. **Stage 3**: Data Layer
   - Database integration, models
4. **Stage 4**: Advanced Features
   - Authentication, authorization, advanced queries
5. **Stage 5**: Production Ready
   - Testing, logging, deployment

### CLI Tool Pattern
1. **Stage 1**: Basic Command Structure
   - Argument parsing, help messages
2. **Stage 2**: Core Functionality
   - Main feature implementation
3. **Stage 3**: File/Data Handling
   - Reading/writing files, data processing
4. **Stage 4**: Enhanced UX
   - Interactive prompts, progress indicators
5. **Stage 5**: Distribution
   - Error handling, packaging, documentation

### Library/Package Pattern
1. **Stage 1**: Core API Design
   - Main interface, basic functionality
2. **Stage 2**: Extended Features
   - Additional methods, configurability
3. **Stage 3**: Error Handling
   - Validation, error messages
4. **Stage 4**: Documentation & Examples
   - Usage examples, API docs
5. **Stage 5**: Testing & Publishing
   - Unit tests, package publishing

## Estimating Number of Stages

Consider these factors:
- **Project complexity**: 3-4 stages for simple projects, 5-7 for complex ones
- **User experience level**: More stages for beginners, fewer for experienced developers
- **Scope of learning**: More stages if covering many new concepts

**General Guidelines**:
- **Small projects (Todo app, Calculator)**: 3-4 stages
- **Medium projects (Blog, E-commerce site)**: 5-6 stages
- **Large projects (Social network, Dashboard)**: 6-8 stages

Avoid:
- Too few stages (< 3): Not enough learning progression
- Too many stages (> 8): Overwhelming and hard to maintain focus
